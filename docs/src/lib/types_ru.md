``` @meta
CurrentModule = DataFrames
```

# Types

``` @index
Pages = ["types.md"]
```

## Структура иерархии типов

`AbstractDataFrame` - это абстрактный тип, который предоставляет интерфейс для типов фреймов данных. Он не предназначен в качестве полностью универсального интерфейса для работы с табличными данными, роль которого выполняют интерфейсы, определенные в [Tables.jl](https://github.com/JuliaData/Tables.jl/).

`DataFrame` является наиболее фундаментальным подтипом `AbstractDataFrame`, который хранит набор столбцов в виде объектов `AbstractVector`. Индексация всех сохраненных столбцов должна основываться на единице. Кроме того, все функции, предоставляемые DataFrames.jl API, обязательно собирают (`collect`) переданные исходные столбцы `AbstractRange` перед сохранением их во `DataFrame`.

`SubDataFrame` - это подтип `AbstractDataFrame`, представляющий представление в `DataFrame`. Он хранит только ссылку на родительский `DataFrame` и информацию о том, какие строки и столбцы из родительского фрейма выбраны (оба в виде целочисленных индексов, ссылающихся на родительский фрейм). Обычно он создается с помощью функции просмотра `view` или возвращается путем индексации в объект `GroupedDataFrame`.

`GroupedDataFrame` - это тип, который хранит результат операции группировки, выполненной над `AbstractDataFrame`. Предполагается, что он будет создан в результате вызова функции `groupby`.

`DataFrameRow` - это представление в виде отдельной строки `AbstractDataFrame`. В нем хранится только ссылка на родительский `DataFrame` и информация о том, какие строки и столбцы из родительского фрейма выбраны (оба в виде целочисленных индексов, ссылающихся на родительский фрейм). Тип `DataFrameRow` поддерживает итерацию по столбцам строки и аналогичен по функциональности типу `NamedTuple`, но допускает модификацию данных, хранящихся в родительском `DataFrame`, и отражает изменения, внесенные в родительский фрейм после создания представления. Обычно объекты типа `DataFrameRow` обнаруживаются при возврате функцией `eachrow` или при обращении к отдельной строке `DataFrame` или `SubDataFrame` с помощью `getindex` или `view`.

Функция `eachrow` возвращает значение типа `DataFrameRows`, которое служит в качестве итератора по строкам `AbstractDataFrame`, возвращая объекты `DataFrameRow`. `DataFrameRows` является подтипом `AbstractVector` и поддерживает его интерфейс, за исключением того, что он доступен только для чтения.

Аналогично, функция `eachcol` возвращает значение типа `DataFrameColumns`, которое не является `AbstractVector`, но поддерживает большую часть своего API. Основные отличия заключаются в том, что он доступен только для чтения и что функция keys возвращает вектор `Symbol` (а не целые числа, как для обычных векторов).

Обратите внимание, что `DataFrameRows` и `DataFrameColumns` не экспортируются и не должны создаваться напрямую, а с использованием функций `eachrow` и `eachcol`.

Типы `RepeatedVector` и `StackedVector` являются подтипами `AbstractVector` и поддерживают его интерфейс, за исключением того, что они доступны только для чтения. Обратите внимание, что они не экспортируются и не должны создаваться напрямую, но они являются столбцами `DataFrame`, возвращаемого `stack` с `view=true`.

Тип `ByRow` - это специальный тип, используемый для операций выделения, чтобы сигнализировать о том, что к каждому элементу (строке) выделения должна быть применена обернутая функция.

Тип `AsTable` - это специальный тип, используемый для операций выбора, чтобы сигнализировать о том, что столбцы, выбранные с помощью встроенного селектора, должны быть переданы функции как `NamedTuple`, или чтобы сигнализировать о том, что требуется расширить возвращаемое значение преобразования на несколько столбцов.

## [Схема обработки столбцов `DataFrame`](@id%20man-columnhandling)

При построении `DataFrame` столбцы копируются по умолчанию. Вы можете отключить это поведение, установив в качестве аргумента ключевого слова `copycols` значение `false`. Исключением является то, что если `AbstractRange` передается как столбец, то он всегда преобразуется в `Vector`.

Также функции, которые преобразуют `DataFrame` для создания нового `DataFrame`, выполняют копирование столбцов, если только им не передано `copycols=false` (доступно только для функций, которые могли бы выполнить преобразование без копирования столбцов). Примерами таких функций являются [`vcat`](@ref), [`cat`](@ref), [`filter`](@ref), [`drop missing`](@ref), `getindex`, [`copy`](@ref) или конструктор [`Data Frame`](@ref), упомянутый выше.

Общий конструктор с одним аргументом `DataFrame(table)` по умолчанию имеет значение `copycols=nothing`, что означает, что столбцы копируются, если только `table` не сигнализирует о том, что копирование столбцов не требуется (это делается путем обертывания исходной таблицы в `Tables.CopiedColumns`). [CSV.jl](https://csv.juliadata.org/stable) выполняет это при вызове `CSV.read(file, DataFrame)`, поскольку столбцы создаются только для использования в конструкторе `DataFrame`. Другим примером является [`Arrow.Table`](https://arrow.juliadata.org/dev/manual/#Arrow.Table), где данные arrow по своей сути неизменяемы, поэтому столбцы в любом случае не могут быть случайно изменены. Чтобы иметь возможность изменять данные со стрелками, необходимо материализовать столбцы, что можно сделать с помощью `DataFrame(arrow_table, copycols=true)`.

Напротив, функции, которые создают представление `DataFrame`, по определению *не* создают копий столбцов и поэтому требуют особой осторожности. Это включает в себя `view`, который возвращает `SubDataFrame` или `DataFrameRow`, и `groupby`, который возвращает `GroupedDataFrame`.

Частичным исключением из этого правила является функция [`stack`](@ref) с `view=true`, которая создает `DataFrame`, содержащий представления столбцов из исходного `DataFrame`.

Встроенные функции, имена которых заканчиваются на "!" (например, `sort!` или [`dropmissing!`](@ref),`setindex!`, `push!`, `append!`) может изменять векторы столбцов `DataFrame`, которые они принимают в качестве аргумента. Эти функции безопасны для вызова в соответствии с правилами, описанными выше, *за исключением* случаев, когда используется представление `DataFrameRow` (через `GroupedDataFrame`,`DataFrameRow` или `GroupedDataFrame`). В последнем случае вызов такой функции для родительского объекта может привести к повреждению представления, что приведет к ошибкам запуска, молчаливому возврату неверных данных или даже к аварийному завершению работы Julia. Такое же предостережение применяется, когда `DataFrame` был создан с использованием столбцов другого `DataFrame` без копирования (например, когда `copycols=false` в таких функциях, как `DataFrame` или `hcat`).

Можно получить прямой доступ к столбцу `col` фрейма данных `DataFrame` `df` (например, это может быть полезно в коде, критически важном для производительности, чтобы избежать копирования), используя один из следующих методов:

-   через функцию `getproperty`, используя синтаксис `df.col`;
-   через функцию `getindex`, используя синтаксис `df[!, :col]` (обратите внимание, что это отличается от `df[:, :col]`, который копирует);
-   путем создания объекта `DataFrameColumns` с помощью функции [`eachcol`](@ref);
-   путем вызова функции `parent` для представления столбца `DataFrame`, например `parent(@view df[:, :col])`;
-   сохраняя ссылку на столбец перед созданием `DataFrame` с помощью `copycols=false`;

Столбец, полученный из `DataFrame` с использованием одного из вышеуказанных методов, не следует изменять без предупреждения, поскольку:

-   изменение размера вектора-столбца приведет к повреждению его родительского `DataFrame` и любых связанных с ним представлений, поскольку методы проверяют длину столбца только при его добавлении в `DataFrame`, а затем предполагают, что все столбцы имеют одинаковую длину;
-   изменение порядка значений в векторе-столбце (например, с помощью `sort!`) приведет к нарушению согласованности строк с другими столбцами, что также повлияет на представления (если таковые имеются).;
-   изменение значений, содержащихся в векторе-столбце, допустимо до тех пор, пока он не используется в качестве группирующего столбца в `GroupedDataFrame`, созданном на основе `DataFrame`.

## Спецификация типов

``` @docs
AbstractDataFrame
AsTable
DataFrame
DataFrameRow
GroupedDataFrame
GroupKey
GroupKeys
SubDataFrame
DataFrameRows
DataFrameColumns
RepeatedVector
StackedVector
```